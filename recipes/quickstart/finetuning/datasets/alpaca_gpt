import copy
from datasets import load_dataset
import torch

def check_header(targets, seq):
    for i in range(len(seq) - 3):
        if seq[i:i+3] in targets:
            return True
    return False

def replace_target(target, seq):
    for i in range(len(seq) - 3):
        if seq[i:i+3] == target:
            seq[i], seq[i+1], seq[i+2] = -100, -100, -100
    return seq

def tokenize_dialogs_with_images(dialogs, images, processor):
    text_prompt = processor.apply_chat_template(dialogs)
    batch = processor(images=images, text=text_prompt, padding=True, return_tensors="pt")
    label_list = []
    for i in range(len(batch["input_ids"])):
        dialog_tokens = batch["input_ids"][i].tolist()
        labels = copy.copy(dialog_tokens)
        eot_indices = [i for i, n in enumerate(labels) if n == 128009]  # Assuming this is the end-of-turn token ID
        last_idx = 0
        prompt_header_seqs = [[128006, 9125, 128007], [128006, 882, 128007]]
        for n, idx in enumerate(eot_indices):
            current_seq = labels[last_idx:idx+1]
            if check_header(prompt_header_seqs, current_seq):
                labels[last_idx:idx+1] = [-100] * (idx - last_idx + 1)
            else:
                last_idx = idx + 1
        assistant_header_seq = [128006, 78191, 128007]  # Assuming this is the assistant header token ID
        labels = replace_target(assistant_header_seq, labels)
        for i in range(len(labels)):
            if labels[i] == processor.tokenizer.pad_token_id or labels[i] == 128256:  # 128256 is image token index
                labels[i] = -100
        label_list.append(labels)
    batch["labels"] = torch.tensor(label_list)
    return batch

def tokenize_dialogs_text_only(dialogs, processor):
    text_prompt = processor.apply_chat_template(dialogs)
    batch = processor(text=text_prompt, padding=True, return_tensors="pt")
    label_list = []
    for i in range(len(batch["input_ids"])):
        dialog_tokens = batch["input_ids"][i].tolist()
        labels = copy.copy(dialog_tokens)
        eot_indices = [i for i, n in enumerate(labels) if n == processor.tokenizer.eos_token_id]
        last_idx = 0
        prompt_header_seqs = [[128006, 9125, 128007], [128006, 882, 128007]]
        for idx in eot_indices:
            current_seq = labels[last_idx:idx+1]
            if any(seq in current_seq for seq in prompt_header_seqs):
                labels[last_idx:idx+1] = [-100] * (idx - last_idx + 1)
            else:
                last_idx = idx + 1
        assistant_header_seq = [128006, 78191, 128007]
        labels = replace_target(assistant_header_seq, labels)
        for i in range(len(labels)):
            if labels[i] == processor.tokenizer.pad_token_id:
                labels[i] = -100
        label_list.append(labels)
    batch["labels"] = torch.tensor(label_list)
    return batch

def get_custom_dataset(dataset_config, processor, split, split_ratio=0.9):
    dataset_dict = load_dataset("mylesgoose/alpaca-cleaned-gpt4-turbo", name="default")
    dataset = dataset_dict['train']
    dataset = dataset.select(range(2000)) #comment out to do entre dataset
    dataset = dataset.train_test_split(test_size=1-split_ratio, shuffle=True, seed=42)[split]
    return dataset

class DataCollator:
    def __init__(self, processor):
        self.processor = processor
        self.processor.tokenizer.padding_side = "right"

    def __call__(self, samples):
        dialogs = []
        for sample in samples:
            user_text = sample["instruction"].strip()
            if sample["input"].strip():
                user_text += " " + sample["input"].strip()
            dialog = [
                {"role": "user", "content": [{"type": "text", "text": user_text}]},
                {"role": "assistant", "content": [{"type": "text", "text": sample["output"].strip()}]}
            ]
            dialogs.append(dialog)

        if "image" in samples[0]:
            images = [[sample["image"].convert("RGB")] for sample in samples]
            return tokenize_dialogs_with_images(dialogs, images, self.processor)
        else:
            return tokenize_dialogs_text_only(dialogs, self.processor)

def get_data_collator(processor):
    return DataCollator(processor)
